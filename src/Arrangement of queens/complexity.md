### best_implementation.py - O(n!)
На каждом уровне рекурсии рассматривает только безопасные позиции, что занимает O(n) времени, но основная сложность определяется количеством валидных перестановок, которое растет факториально, следовательно для данного алгоритма временная сложность составляет O(n!)
### iteration_solution.py - O(n!)
Имеет такую же временную сложность, как и **best_implementation.py**, но не требует работы с двумерным массивом
### iteration_solution.py - O(n! * n²)
Генерирует все n! перестановок. Для каждой перестановки выполняется проверка конфликтов за O(n²) времени, что дает общую временную сложность n! × n².
